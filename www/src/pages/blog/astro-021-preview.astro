---
import { Markdown, Code } from 'astro/components';
import BaseHead from '../../components/BaseHead.astro';
import BlogHeader from '../../components/BlogHeader.astro';
import BlogPost from '../../components/BlogPost.astro';
import GoogleAnalytics from '../../components/GoogleAnalytics.astro';

let title = 'Astro 0.21 Preview: Vite + WASM = ‚ö°Ô∏è';
let description = `Get a sneak preview of what's next for Astro, including our new Vite build engine and WASM-powered Go compiler.`;
let publishDate = 'September 23, 2021';
let permalink = 'https://astro.build/blog/astro-021-preview';
let lang = 'en';
---

<html lang={ lang ?? 'en' }>
  <head>
    <BaseHead title={title} description={description} canonicalURL={permalink} image="https://astro.build/assets/blog/demo-day-2021-09/social.png" />
    <link rel="stylesheet" href={Astro.resolve('../../scss/blog.css')} />
    <style>
      .chat-messages {

      }
    </style>
  </head>

  <body>
    <BlogHeader />
    <BlogPost title={title} author="fred" heroImage="/assets/blog/demo-day-2021-09/hero.png" publishDate={publishDate}>
      <Markdown>
        Astro v0.21.0 will be our biggest release yet. At a high-level, it includes:

        - [A new build engine, powered by Vite](#hello-vite)
        - [A new WASM compiler, written in Go](#hello-wasm)
        - [Brand new features, like Components-in-Markdown](#components-in-markdown)
        - [A new system for HTML live-updating via HMR](#hmr-meet-html)

        You can try out this release today on StackBlitz, or by running `npm init astro --next` in a new directory on your machine.

        Astro is graduating from "proof of concept" to become a production-ready tool for professional web developers. To celebrate, here are more highlights and details on what you can expect in Astro v0.21.0 and beyond.

        ## Hello, Vite!

        Astro 0.21 replaces our current internal¬†build engine with Vite. 

        Astro was originally built on Snowpack. But after experimenting with Vite we came away very impressed. Vite is well-maintained, well-documented, a bit faster, has great error messages, and has been building clear community buy-in across multiple frameworks. SSR dependency handling can be a bit flakey at times, but the Vite team is aware of this and working on it.

        So now, when Evan You tweets about [some great performance optimization](https://twitter.com/youyuxi/status/1440718351802646550) that they're making in Vite you can be certain that the same speed is coming to Astro as well. 

        Best of all, Vite unlocks access to the entire Rollup ecosystem of plugins. Starting in v0.21.0, you'll enable new features like [image optimizations](https://github.com/JonasKruckenberg/imagetools/tree/main/packages/vite) and [icon loading](https://github.com/antfu/unplugin-icons) with just a few simple plugins. Magic!

        This switch from Snowpack to Vite might come as a surprise to some: Both Drew and myself are maintainers on both projects. This was obviously a hard decision for us to make. But ultimately, after working with both build tools I can confidently say that Vite will be a great choice for Astro. We're excited to take what we've learned and contribute¬†our experience back into improving Vite.

        If you're curious to learn more, you can read more about this transition from my perspective as Snowpack maintainer [here.](https://dev.to/fredkschott/5-more-things-i-learned-building-snowpack-to-20-000-stars-5dc9)


        ## Hello, WASM!

        Astro 0.21 features another huge low-level improvement: the brand new [@astrojs/compiler](https://github.com/snowpackjs/astro-compiler-next). Astro's new compiler is written in Go and distributed as WASM. You can run it right in your browser, or on the server in Node.js and Deno. 

        The new [@astrojs/compiler](https://github.com/snowpackjs/astro-compiler-next) unlocks:

        - **Flexibility:** Run the compiler anywhere with WASM.
        - **Speed:** Build sites faster with Go's compiled-language performance.
        - **Stability:** Writing our own compiler allowed us to fix some long-standing bugs.

        You can play with the new compiler today right in your browser at https://astro.build/play. This REPL is just one example of what is now possible when you have a fast, runs-anywhere compiler. 

        Shout out to [Nate Moore](https://twitter.com/n_moore) who did a really incredible job with this project.


        ## Components in Markdown

        Our most requested feature ***by far*** has been the ability to use components directly in Markdown. After months of work, we're excited to announce that this feature is finally coming to Astro.

        Starting in v0.21.0, you can import components inside of your Markdown frontmatter via an optional `setup` script. Once imported, your components can be used anywhere on the page:

        <Code code={`---
title: 'Astro 0.21 Early Preview'
setup: |
  import Logo from '../components/Logo.astro';
  import ReactCounter from '../components/Counter.jsx';
---

# Astro now supports components in Markdown!

<Logo />

- Back to markdown here. 
- Supports static Astro components.
- Supports dynamic React/Vue/Svelte components!

<ReactCounter start={0} client:load /> 
`} lang="astro" />

        This new `setup` script was designed for maximum flexibility. We'll keep improving this API going forward with planned support for default components, default layouts, and markdown component overrides.


        ## HMR, meet HTML

        Starting in v0.21.0, Astro will support full HMR for Astro components and pages. Change any `.astro` file in your codebase, and watch the dev server update the page without a full refresh and without losing any client state.

        Astro has always supported powerful HMR updates for client-side JavaScript components like React, Preact, Svelte, Vue, and Solid.js. But adding this for Astro was a fun challenge because Astro components are just static HTML. Our "Zero JavaScript" approach meant that there was no "Astro runtime" to hook into for updates. We had to get creative.

        Now, Astro's dev server sends HTML updates to the browser and then runs a small script to diff those updates against the current page. This creates a more granular, component-level HMR update that won't impact the rest of the page.


        ## Try it today

        If you've read this far, we'd love your help trying out the latest release before launch. You can try out our latest release today on StackBlitz, or by running `npm init astro -- --next` in a new directory on your machine.

        Leave feedback, report bugs, and get involved with Astro's development in our [Discord server](https://astro.build/chat). You can also [follow along](https://twitter.com/astrodotbuild) on Twitter.

        Keep your eyes on the sky, üë©‚ÄçüöÄ Astronaut!
      </Markdown>
    </BlogPost>

    <GoogleAnalytics />
  </body>
</html>
